<!DOCTYPE html>
<html>
<head>
    <title>Gerador de Arranjo de Tiles</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css">
    <style>
        /* Estilos (como antes) */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f8f9fa;
            color: #343a40;
        }
        .container {
            width: 95%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            background-color: white;
            border-radius: 8px;
        }
        h1 {
            color: #28a745;
            margin-bottom: 30px;
            text-align: center;
            font-weight: bold;
        }
        .content {
            display: flex;
            align-items: start;
            gap: 30px;
        }
        .parameters {
            width: 30%;
            min-width: 280px;
        }
        .plot-container {
            width: 70%;
            display: flex;
            justify-content: center;
        }
        label {
            display: block;
            margin-top: 15px;
            margin-bottom: 5px;
            position: relative;
            font-weight: 600;
        }
        label span {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            width: max-content;
            max-width: 350px;
            background-color: #343a40;
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.3s ease;
            z-index: 1;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            font-size: 0.9em;
        }
        label:hover span {
            visibility: visible;
            opacity: 1;
        }
        input[type="number"], input[type="text"], input[type="checkbox"] {
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 0.9em;
            margin-bottom: 10px;
            width: calc(100% - 18px);
        }
        input[type="number"], input[type="text"] {
            width: 120px;
        }
        button {
            margin-top: 25px;
            padding: 12px 24px;
            background-color: #28a745;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 6px;
            font-weight: 500;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #218838;
        }
        #plot {
            width: 100%;
            max-width: 800px;
            height: 600px;
        }
        .message {
            margin-top: 15px;
            padding: 12px;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 4px;
            color: #721c24;
        }
        .message.success {
            background-color: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }
        .snippet-container {
            margin-top: 30px;
            position: relative;
        }
        textarea {
            width: calc(100% - 20px);
            height: 220px;
            margin-top: 15px;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.85em;
            resize: vertical;
        }
        .copy-button {
            position: absolute;
            top: 15px;
            right: 10px;
            padding: 6px 12px;
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            z-index: 10;
            transition: background-color 0.3s ease;
        }
        .copy-button:hover {
            background-color: #0056b3;
        }
        .copy-button i {
            font-size: 1.1em;
        }

        /* Progress Bar */
        .progress-bar-container {
            width: 100%;
            background-color: #e9ecef;
            border-radius: 8px;
            margin-top: 20px;
            overflow: hidden;
            display: none; /* Inicialmente oculto */
        }

        .progress-bar {
            width: 0%;
            height: 25px;
            background-color: #28a745;
            text-align: center;
            line-height: 25px;
            color: white;
            transition: width 0.5s ease;
        }

        /* Plotly Plot Container */
        .plotly-plot-container {
            margin-top: 40px;
            display: flex;
            justify-content: center;
        }

        /* Media Queries para Responsividade */
        @media (max-width: 1024px) {
            .content {
                flex-direction: column;
                align-items: center;
            }
            .parameters, .plot-container {
                width: 95%;
                min-width: 0;
            }
            .plot-container {
                margin-top: 30px;
            }
            #plot {
                height: 500px;
            }
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 22px;
            }
            label span {
                max-width: 95%;
                font-size: 0.8em;
            }
            input[type="number"], input[type="text"] {
                width: 95%;
            }
            #plot {
                height: 400px;
            }
            textarea {
                font-size: 0.8em;
            }
        }

        /* Estilos para o gráfico interativo */
        .interactive-plot-container {
            margin-top: 40px;
            display: flex;
            justify-content: center;
        }

        .interactive-plot {
            width: 100%;
            max-width: 1200px;
            height: 600px;
        }
    </style>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>Gerador de Arranjo de Tiles</h1>

        <div class="content">
            <div class="parameters">
                <label for="num_spirals">
                    Número de Espirais:
                    <span>Controla o número de espirais no arranjo.</span>
                </label>
                <input type="number" id="num_spirals" value="6">

                <label for="tiles_per_spiral">
                    Tiles por Espiral:
                    <span>Define quantos tiles serão dispostos em cada espiral.</span>
                </label>
                <input type="number" id="tiles_per_spiral" value="5">

                <label for="base_radius">
                    Raio Base (x tile_size):
                    <span>O raio inicial do arranjo, medido a partir do centro até o início das espirais. Multiplicado pelo tamanho do tile.</span>
                </label>
                <input type="number" id="base_radius" value="2">

                <label for="radius_growth_factor">
                    Fator de Crescimento do Raio (x tile_size):
                    <span>Fator pelo qual o raio aumenta a cada novo tile dentro de uma espiral. Multiplicado pelo tamanho do tile.</span>
                </label>
                <input type="number" id="radius_growth_factor" value="1.5">

                <label for="angle_offset_factor">
                    Fator de Offset do Ângulo:
                    <span>Determina o ângulo inicial para a disposição dos tiles em cada espiral.</span>
                </label>
                <input type="number" id="angle_offset_factor" value="0.08333">

                <label for="angle_variation_factor">
                    Fator de Variação do Ângulo:
                    <span>Adiciona uma variação angular adicional para cada tile, permitindo curvas mais complexas nas espirais.</span>
                </label>
                <input type="number" id="angle_variation_factor" value="0">

                <label for="exponential_radius_factor">
                    Fator Exponencial do Raio:
                    <span>Aplica um crescimento exponencial ao raio, fazendo com que a distância entre os tiles aumente de forma não linear.</span>
                </label>
                <input type="number" id="exponential_radius_factor" value="0">

                <label for="exponential_angle_factor">
                    Fator Exponencial do Ângulo:
                    <span>Introduz uma variação exponencial no ângulo, alterando a curvatura das espirais de forma não linear.</span>
                </label>
                <input type="number" id="exponential_angle_factor" value="0">

                <label for="rotation_per_spiral">
                    Rotação por Espiral:
                    <span>Aplica uma rotação adicional a cada espiral subsequente, criando um efeito de torção no arranjo.</span>
                </label>
                <input type="number" id="rotation_per_spiral" value="0">

                <label for="center_tile">
                    Tile Central:
                    <span>Adiciona um tile no centro do arranjo, servindo como ponto de referência.</span>
                </label>
                <input type="checkbox" id="center_tile" checked>

                <label for="station_name">
                    Nome da Estação:
                    <span>Um nome descritivo para o arranjo gerado.</span>
                </label>
                <input type="text" id="station_name" value="Station">

                <button onclick="generatePlot()">Gerar Station</button>

                <label for="phi_angle">
                    Ângulo Phi (em graus, -180 a 180):
                    <span>Define o ângulo Phi para o gráfico interativo.</span>
                </label>
                <input type="number" id="phi_angle" value="90" min="-180" max="180">

                <button onclick="generateInteractivePlot()">Gerar Gráfico Interativo</button>

                <div id="message-container"></div>

                <div class="progress-bar-container">
                    <div class="progress-bar"></div>
                </div>
            </div>

            <div class="plot-container">
                <div id="plot"></div>
            </div>
        </div>

        <div class="interactive-plot-container">
            <div id="interactive-plot" class="interactive-plot"></div>
        </div>

        <div class="snippet-container">
            <textarea id="code-snippet" readonly></textarea>
            <button class="copy-button" onclick="copySnippet()"><i class="fas fa-paste"></i></button>
        </div>
    </div>

    <script>
        // ==================== Parâmetros do Tile ====================
        const dx = 176.0695885;
        const dy = 167.5843071;
        const N = 2;
        const M = 8;

        // Cria o array do tile
        let tile_array = createPlanarArray(dx, dy, N, M);
        tile_array = tile_array.map(point => [point[0] - tile_array.reduce((sum, p) => sum + p[0], 0) / tile_array.length, point[1] - tile_array.reduce((sum, p) => sum + p[1], 0) / tile_array.length]);

        const tile_size_x = Math.max(...tile_array.map(p => p[0])) - Math.min(...tile_array.map(p => p[0]));
        const tile_size_y = Math.max(...tile_array.map(p => p[1])) - Math.min(...tile_array.map(p => p[1]));
        const tile_size = Math.sqrt(tile_size_x ** 2 + tile_size_y ** 2);

        function createPlanarArray(dx, dy, N, M) {
            const array = [];
            for (let i = 0; i < N; i++) {
                for (let j = 0; j < M; j++) {
                    array.push([i * dx, j * dy]);
                }
            }
            return array;
        }

        function rotatePoints(points, angle) {
            const R = [
                [Math.cos(angle), -Math.sin(angle)],
                [Math.sin(angle), Math.cos(angle)]
            ];
            return points.map(point => [
                point[0] * R[0][0] + point[1] * R[0][1],
                point[0] * R[1][0] + point[1] * R[1][1]
            ]);
        }

        function isCollision(tile1_center, tile1_angle, tile2_center, tile2_angle, tile_array) {
            const tile_size_x = Math.max(...tile_array.map(p => p[0])) - Math.min(...tile_array.map(p => p[0]));
            const tile_size_y = Math.max(...tile_array.map(p => p[1])) - Math.min(...tile_array.map(p => p[1]));

            function createHitbox(center, angle, size_x, size_y) {
                const half_x = size_x / 2;
                const half_y = size_y / 2;

                let corners = [
                    [-half_x, -half_y],
                    [half_x, -half_y],
                    [half_x, half_y],
                    [-half_x, half_y]
                ];

                const rotated_corners = rotatePoints(corners, angle);
                return rotated_corners.map(corner => [corner[0] + center[0], corner[1] + center[1]]);
            }

            const hitbox1 = createHitbox(tile1_center, tile1_angle, tile_size_x, tile_size_y);
            const hitbox2 = createHitbox(tile2_center, tile2_angle, tile_size_x, tile_size_y);

            function separatingAxis(hitbox1, hitbox2) {
                for (let i = 0; i < 4; i++) {
                    const edge = [hitbox1[(i + 1) % 4][0] - hitbox1[i][0], hitbox1[(i + 1) % 4][1] - hitbox1[i][1]];
                    const axis = [-edge[1], edge[0]];

                    const projection1 = hitbox1.map(point => point[0] * axis[0] + point[1] * axis[1]);
                    const projection2 = hitbox2.map(point => point[0] * axis[0] + point[1] * axis[1]);

                    const min1 = Math.min(...projection1);
                    const max1 = Math.max(...projection1);
                    const min2 = Math.min(...projection2);
                    const max2 = Math.max(...projection2);

                    if (max1 < min2 || max2 < min1) {
                        return true;
                    }
                }
                return false;
            }

            if (!(separatingAxis(hitbox1, hitbox2) || separatingAxis(hitbox2, hitbox1))) {
                const tileCenter = [(hitbox2[0][0] + hitbox2[2][0]) / 2, (hitbox2[0][1] + hitbox2[2][1]) / 2];
                return { collision: true, tileCenter: tileCenter };
            }

            return { collision: false, tileCenter: null };
        }

        function createStationArray(tiles_config, tile_array) {
            const array_tot = [];
            const collision_messages = [];
            const tile_array_centered = tile_array.map(point => [
                point[0] - tile_array.reduce((sum, p) => sum + p[0], 0) / tile_array.length,
                point[1] - tile_array.reduce((sum, p) => sum + p[1], 0) / tile_array.length
            ]);

            for (let i = 0; i < tiles_config.length; i++) {
                const tile_center = tiles_config[i][0];
                const tile_angle = tiles_config[i][1];
                let valid_position = true;
                let collisionInfo = null;

                for (let j = 0; j < i; j++) {
                    const existing_tile_center = tiles_config[j][0];
                    const existing_tile_angle = tiles_config[j][1];
                    collisionInfo = isCollision(tile_center, tile_angle, existing_tile_center, existing_tile_angle, tile_array);
                    if (collisionInfo.collision) {
                        valid_position = false;
                        break;
                    }
                }

                if (valid_position) {
                    const rotated_tile = rotatePoints(tile_array_centered, tile_angle);
                    const translated_tile = rotated_tile.map(point => [point[0] + tile_center[0], point[1] + tile_center[1]]);
                    translated_tile.forEach(point => array_tot.push([...point, 0]));
                } else {
                    collision_messages.push(`Colisão detectada no tile ${i + 1}. Coordenadas do centro: (${collisionInfo.tileCenter[0].toFixed(2)}, ${collisionInfo.tileCenter[1].toFixed(2)}). Posição ignorada.`);
                }
            }

            return [array_tot, collision_messages];
        }

        function generateSpiralTileArrangement(
            num_spirals = 6,
            tiles_per_spiral = 5,
            base_radius = 2.0,
            radius_growth_factor = 1.5,
            angle_offset_factor = 1 / 12,
            angle_variation_factor = 0.0,
            exponential_radius_factor = 0.0,
            exponential_angle_factor = 0.0,
            rotation_per_spiral = 0.0,
            center_tile = true,
            station_name = ''
        ) {
            const tile_arrangement = [];

            if (center_tile) {
                tile_arrangement.push([[0, 0], 0]);
            }

            for (let p = 0; p < num_spirals; p++) {
                const spiral_angle = p * (2 * Math.PI / num_spirals) + p * rotation_per_spiral;
                for (let i = 0; i < tiles_per_spiral; i++) {
                    const r = (base_radius + i * radius_growth_factor) * (1 + exponential_radius_factor) ** i;
                    const angle = (spiral_angle + i * Math.PI * angle_offset_factor + i * angle_variation_factor) * (1 + exponential_angle_factor) ** i;

                    const x = r * Math.cos(angle);
                    const y = r * Math.sin(angle);
                    const orientation_angle = angle + Math.PI / 2;

                    tile_arrangement.push([[x, y], orientation_angle]);
                }
            }

            return tile_arrangement;
        }

        function generatePlot() {
            const numSpirals = parseFloat(document.getElementById('num_spirals').value);
            const tilesPerSpiral = parseFloat(document.getElementById('tiles_per_spiral').value);
            const baseRadius = parseFloat(document.getElementById('base_radius').value);
            const radiusGrowthFactor = parseFloat(document.getElementById('radius_growth_factor').value);
            const angleOffsetFactor = parseFloat(document.getElementById('angle_offset_factor').value);
            const angleVariationFactor = parseFloat(document.getElementById('angle_variation_factor').value);
            const exponentialRadiusFactor = parseFloat(document.getElementById('exponential_radius_factor').value);
            const exponentialAngleFactor = parseFloat(document.getElementById('exponential_angle_factor').value);
            const rotationPerSpiral = parseFloat(document.getElementById('rotation_per_spiral').value);
            const centerTile = document.getElementById('center_tile').checked;
            const stationName = document.getElementById('station_name').value;

            const adaptedBaseRadius = baseRadius * tile_size;
            const adaptedRadiusGrowthFactor = radiusGrowthFactor * tile_size;

            const tileArrangement = generateSpiralTileArrangement(
                numSpirals,
                tilesPerSpiral,
                adaptedBaseRadius,
                adaptedRadiusGrowthFactor,
                angleOffsetFactor,
                angleVariationFactor,
                exponentialRadiusFactor,
                exponentialAngleFactor,
                rotationPerSpiral,
                centerTile,
                stationName
            );

            const [station, collisionMessages] = createStationArray(tileArrangement, tile_array);

            displayPlot(station, collisionMessages, stationName);
            updateCodeSnippet();
        }

        function displayPlot(stationData, collisionMessages, stationName) {
            const xValues = stationData.map(point => point[0]);
            const yValues = stationData.map(point => point[1]);

            const plotData = [{
                x: xValues,
                y: yValues,
                mode: 'markers',
                type: 'scatter'
            }];

            const layout = {
                title: stationName,
                autosize: true,
                xaxis: {
                    scaleanchor: "y",
                    scaleratio: 1
                },
                yaxis: {
                    scaleanchor: "x",
                    scaleratio: 1
                }
            };

            Plotly.newPlot('plot', plotData, layout);

            const messageContainer = document.getElementById('message-container');
            messageContainer.innerHTML = '';
            if (collisionMessages && collisionMessages.length > 0) {
                collisionMessages.forEach(message => {
                    displayMessage(message, 'warning');
                });
            } else {
                displayMessage('Nenhuma colisão detectada.', 'success');
            }
        }

        function displayMessage(message, type) {
            const messageContainer = document.getElementById('message-container');
            const div = document.createElement('div');
            div.className = `message ${type === 'success' ? 'success' : ''}`;
            div.textContent = message;
            messageContainer.appendChild(div);
        }

        function updateCodeSnippet() {
            const numSpirals = document.getElementById('num_spirals').value;
            const tilesPerSpiral = document.getElementById('tiles_per_spiral').value;
            const baseRadius = document.getElementById('base_radius').value;
            const radiusGrowthFactor = document.getElementById('radius_growth_factor').value;
            const angleOffsetFactor = document.getElementById('angle_offset_factor').value;
            const angleVariationFactor = document.getElementById('angle_variation_factor').value;
            const exponentialRadiusFactor = document.getElementById('exponential_radius_factor').value;
            const exponentialAngleFactor = document.getElementById('exponential_angle_factor').value;
            const rotationPerSpiral = document.getElementById('rotation_per_spiral').value;
            const centerTile = document.getElementById('center_tile').checked;
            const stationName = document.getElementById('station_name').value;

            const snippet = `array_tiles_station = generate_spiral_tile_arrangement(
    num_spirals=${numSpirals},
    tiles_per_spiral=${tilesPerSpiral},
    base_radius=${baseRadius} * tile_size,
    radius_growth_factor=${radiusGrowthFactor} * tile_size,
    angle_offset_factor=${angleOffsetFactor},
    angle_variation_factor=${angleVariationFactor},
    exponential_radius_factor=${exponentialRadiusFactor},
    exponential_angle_factor=${exponentialAngleFactor},
    rotation_per_spiral=${rotationPerSpiral},
    center_tile=${centerTile ? 'True' : 'False'},
    station_name='${stationName}'
)`;
            document.getElementById('code-snippet').value = snippet;
        }

        let copyIconTimeout;

        function copySnippet() {
            const snippetTextarea = document.getElementById('code-snippet');
            snippetTextarea.select();
            document.execCommand('copy');

            const copyButton = document.querySelector('.copy-button i');
            copyButton.classList.remove('fa-paste');
            copyButton.classList.add('fa-check');

            clearTimeout(copyIconTimeout);
            copyIconTimeout = setTimeout(() => {
                copyButton.classList.remove('fa-check');
                copyButton.classList.add('fa-paste');
            }, 2000);
        }

        // Função para converter radianos para graus
        function radToDeg(radians) {
            return radians * (180 / Math.PI);
        }

        // Função para converter graus para radianos
        function degToRad(degrees) {
            return degrees * (Math.PI / 180);
        }

        // Função para calcular a magnitude do campo elétrico
        function calculateMagnitude(re, im) {
            return Math.sqrt(re * re + im * im);
        }

        function rotateField(data, angle_rad) {
            const rotated_data = JSON.parse(JSON.stringify(data)); // Cria uma cópia profunda dos dados
            const angle_deg = radToDeg(angle_rad);
        
            for (let i = 0; i < rotated_data.length; i++) {
                if (rotated_data[i]['Theta [deg]'] === angle_deg) {
                    const rETheta = rotated_data[i]['rETheta [V]'];
                    const rEPhi = rotated_data[i]['rEPhi [V]'];
        
                    const rotation_matrix = [
                        [Math.cos(angle_rad), -Math.sin(angle_rad)],
                        [Math.sin(angle_rad), Math.cos(angle_rad)]
                    ];
        
                    const rotated_components = [
                        rotation_matrix[0][0] * rETheta.real + rotation_matrix[0][1] * rEPhi.real,
                        rotation_matrix[1][0] * rETheta.real + rotation_matrix[1][1] * rEPhi.real
                    ];
        
                    rotated_data[i]['rETheta [V]'].real = rotated_components[0];
                    rotated_data[i]['rEPhi [V]'].real = rotated_components[1];
        
                    // Recalcula rETotal
                    rotated_data[i]['rETotal [V]'] = calculateMagnitude(rotated_data[i]['rETheta [V]'].real, rotated_data[i]['rEPhi [V]'].real);
                }
            }
        
            return rotated_data;
        }

        // Função para calcular o Fator de Arranjo (Array Factor - AF)
        function computeAF(theta, phi, array, k = 2 * Math.PI / 300, theta_0 = 0, phi_0 = 0, centralize = true, initial_phase = null) {
            const theta_rad = theta.map(degToRad);
            const phi_rad = phi.map(degToRad);
            const theta_0_rad = degToRad(theta_0);
            const phi_0_rad = degToRad(phi_0);
        
            const scan_vector = [Math.sin(theta_0_rad) * Math.cos(phi_0_rad), Math.sin(theta_0_rad) * Math.sin(phi_0_rad), Math.cos(theta_0_rad)];
        
            if (centralize) {
                const mean = array.reduce((acc, val) => [acc[0] + val[0], acc[1] + val[1], acc[2] + val[2]], [0, 0, 0]);
                array = array.map(point => [point[0] - mean[0] / array.length, point[1] - mean[1] / array.length, point[2] - mean[2] / array.length]);
            }
        
            const AF = [];
            for (let i = 0; i < theta_rad.length; i++) {
                const obs_vector_i = [Math.sin(theta_rad[i]) * Math.cos(phi_rad[i]), Math.sin(theta_rad[i]) * Math.sin(phi_rad[i]), Math.cos(theta_rad[i])];
                const diff_i = [obs_vector_i[0] - scan_vector[0], obs_vector_i[1] - scan_vector[1], obs_vector_i[2] - scan_vector[2]];
                let AF_i = { real: 0, imag: 0 };
        
                if (initial_phase === null) {
                    for (let j = 0; j < array.length; j++) {
                        const phase = k * (array[j][0] * diff_i[0] + array[j][1] * diff_i[1] + array[j][2] * diff_i[2]);
                        AF_i.real += Math.cos(phase);
                        AF_i.imag += Math.sin(phase);
                    }
                } else {
                    for (let j = 0; j < array.length; j++) {
                        const phase = k * (array[j][0] * diff_i[0] + array[j][1] * diff_i[1] + array[j][2] * diff_i[2]) + degToRad(initial_phase[j]);
                        AF_i.real += Math.cos(phase);
                        AF_i.imag += Math.sin(phase);
                    }
                }
        
                AF.push(AF_i);
            }
        
            return AF;
        }
        
        // Função para aplicar o AF ao campo
        function applyAFOnField(field, AF) {
            const out_field = JSON.parse(JSON.stringify(field)); // Cria uma cópia profunda
        
            for (let i = 0; i < out_field.length; i++) {
                out_field[i]['rETheta [V]'].real *= AF[i].real;
                out_field[i]['rETheta [V]'].imag *= AF[i].imag;
                out_field[i]['rEPhi [V]'].real *= AF[i].real;
                out_field[i]['rEPhi [V]'].imag *= AF[i].imag;
        
                // Recalcula a magnitude total do campo elétrico
                out_field[i]['rETotal [V]'] = calculateMagnitude(out_field[i]['rETheta [V]'].real, out_field[i]['rEPhi [V]'].real);
            }
        
            return out_field;
        }

        function createStationArrayWithRotatedFields(tiles_config, tile_array, data) {
            const array_tot = [];
            const rotated_fields = [];
            const tile_array_centered = tile_array.map(point => [
                point[0] - tile_array.reduce((sum, p) => sum + p[0], 0) / tile_array.length,
                point[1] - tile_array.reduce((sum, p) => sum + p[1], 0) / tile_array.length
            ]);
        
            for (let i = 0; i < tiles_config.length; i++) {
                const tile_center = tiles_config[i][0];
                const tile_angle = tiles_config[i][1];
                let valid_position = true;
        
                for (let j = 0; j < i; j++) {
                    const existing_tile_center = tiles_config[j][0];
                    const existing_tile_angle = tiles_config[j][1];
                    if (isCollision(tile_center, tile_angle, existing_tile_center, existing_tile_angle, tile_array).collision) {
                        valid_position = false;
                        break;
                    }
                }
        
                if (valid_position) {
                    const rotated_tile = rotatePoints(tile_array_centered, tile_angle);
                    const translated_tile = rotated_tile.map(point => [point[0] + tile_center[0], point[1] + tile_center[1]]);
                    translated_tile.forEach(point => array_tot.push([...point, 0]));
        
                    const rotated_field = rotateField(data, tile_angle);
                    rotated_fields.push(rotated_field);
                } else {
                    console.log(`Colisão detectada no tile ${i + 1}. Posição ignorada.`);
                }
            }
        
            return [array_tot, rotated_fields];
        }

        function db(value) {
            return 20 * Math.log10(value);
        }

        // URLs dos arquivos CSV no GitHub
        const csv_files = [
            "https://raw.githubusercontent.com/Geovannisz/spiral-arrangement-of-tiles/main/data/rE_table_vivaldi.csv",
            "https://raw.githubusercontent.com/Geovannisz/spiral-arrangement-of-tiles/main/data/rE_table_vivaldi_1.5GHz.csv",
            "https://raw.githubusercontent.com/Geovannisz/spiral-arrangement-of-tiles/main/data/rE_table_vivaldi_1.4GHz.csv",
            "https://raw.githubusercontent.com/Geovannisz/spiral-arrangement-of-tiles/main/data/rE_table_vivaldi_1.3GHz.csv",
            "https://raw.githubusercontent.com/Geovannisz/spiral-arrangement-of-tiles/main/data/rE_table_vivaldi_1.2GHz.csv",
            "https://raw.githubusercontent.com/Geovannisz/spiral-arrangement-of-tiles/main/data/rE_table_vivaldi_1.1GHz.csv",
            "https://raw.githubusercontent.com/Geovannisz/spiral-arrangement-of-tiles/main/data/rE_table_vivaldi_0.9GHz.csv",
            "https://raw.githubusercontent.com/Geovannisz/spiral-arrangement-of-tiles/main/data/rE_table_vivaldi_0.8GHz.csv",
            "https://raw.githubusercontent.com/Geovannisz/spiral-arrangement-of-tiles/main/data/rE_table_vivaldi_0.7GHz.csv",
            "https://raw.githubusercontent.com/Geovannisz/spiral-arrangement-of-tiles/main/data/rE_table_vivaldi_0.6GHz.csv",
            "https://raw.githubusercontent.com/Geovannisz/spiral-arrangement-of-tiles/main/data/rE_table_vivaldi_0.5GHz.csv"
        ];

        let data_cache = {};  // Cache para armazenar os dados lidos

        // Função para ler e processar múltiplos arquivos CSV
        function readMultipleTables(files, callback) {
            let filesProcessed = 0;
            const totalFiles = files.length;
            const allData = {};
        
            const progressBarContainer = document.querySelector('.progress-bar-container');
            const progressBar = document.querySelector('.progress-bar');
            progressBarContainer.style.display = 'block';
            progressBar.style.width = '0%';
        
            files.forEach(file => {
                Papa.parse(file, {
                    download: true,
                    header: true,
                    dynamicTyping: true,
                    complete: function(results) {
                        const data = results.data;
                        for (let i = 0; i < data.length; i++) {
                            for (let col of ['re(rETheta)', 'im(rETheta)', 're(rEPhi)', 'im(rEPhi)']) {
                                if (`${col} [mV]` in data[i]) {
                                    data[i][`${col} [V]`] = data[i][`${col} [mV]`] * 1e-3;
                                    delete data[i][`${col} [mV]`];
                                }
                            }
        
                            data[i]['rETheta [V]'] = { real: data[i]['re(rETheta) [V]'], imag: data[i]['im(rETheta) [V]'] };
                            data[i]['rEPhi [V]'] = { real: data[i]['re(rEPhi) [V]'], imag: data[i]['im(rEPhi) [V]'] };
        
                            delete data[i]['re(rETheta) [V]'];
                            delete data[i]['im(rETheta) [V]'];
                            delete data[i]['re(rEPhi) [V]'];
                            delete data[i]['im(rEPhi) [V]'];
        
                            data[i]['rETotal [V]'] = calculateMagnitude(data[i]['rETheta [V]'].real, data[i]['rEPhi [V]'].real);
                        }
        
                        // Extrai a frequência do nome do arquivo
                        const filename = file.split('/').pop();
                        const freqMatch = filename.match(/(\d+(?:\.\d+)?)(?:GHz)?/);
                        const frequency = freqMatch ? freqMatch[1] : 'default';
        
                        allData[frequency] = data;
                        filesProcessed++;
        
                        // Atualiza a barra de progresso
                        const progress = Math.round((filesProcessed / totalFiles) * 100);
                        progressBar.style.width = `${progress}%`;
        
                        if (filesProcessed === totalFiles) {
                            progressBarContainer.style.display = 'none';
                            callback(allData);
                        }
                    }
                });
            });
        }

        function generateInteractivePlot() {
            const stationName = document.getElementById('station_name').value;
            const phi_angle = parseFloat(document.getElementById('phi_angle').value);

            // Verifica se os dados já foram carregados
            if (Object.keys(data_cache).length === 0) {
                // Carrega todos os arquivos CSV
                readMultipleTables(csv_files, function(allData) {
                    data_cache = allData;
                    createPlotWithLoadedData(stationName, phi_angle);
                });
            } else {
                // Usa os dados do cache
                createPlotWithLoadedData(stationName, phi_angle);
            }
        }

        function createPlotWithLoadedData(stationName, phi_angle) {
            // Aqui você pode escolher qual frequência usar, por exemplo, 'default' ou '1.5'
            const selectedFrequency = 'default'; // ou '1.5', '1.4', etc.
            const data = data_cache[selectedFrequency];
        
            // Continua o processo de geração do gráfico interativo
            const numSpirals = parseFloat(document.getElementById('num_spirals').value);
            const tilesPerSpiral = parseFloat(document.getElementById('tiles_per_spiral').value);
            const baseRadius = parseFloat(document.getElementById('base_radius').value);
            const radiusGrowthFactor = parseFloat(document.getElementById('radius_growth_factor').value);
            const angleOffsetFactor = parseFloat(document.getElementById('angle_offset_factor').value);
            const angleVariationFactor = parseFloat(document.getElementById('angle_variation_factor').value);
            const exponentialRadiusFactor = parseFloat(document.getElementById('exponential_radius_factor').value);
            const exponentialAngleFactor = parseFloat(document.getElementById('exponential_angle_factor').value);
            const rotationPerSpiral = parseFloat(document.getElementById('rotation_per_spiral').value);
            const centerTile = document.getElementById('center_tile').checked;
        
            const adaptedBaseRadius = baseRadius * tile_size;
            const adaptedRadiusGrowthFactor = radiusGrowthFactor * tile_size;
        
            const tileArrangement = generateSpiralTileArrangement(
                numSpirals,
                tilesPerSpiral,
                adaptedBaseRadius,
                adaptedRadiusGrowthFactor,
                angleOffsetFactor,
                angleVariationFactor,
                exponentialRadiusFactor,
                exponentialAngleFactor,
                rotationPerSpiral,
                centerTile,
                stationName
            );
        
            // Separar os dados por phi
            const uniquePhis = [...new Set(data.map(item => item['Phi [deg]']))];
            const dataByPhi = {};
            uniquePhis.forEach(phi => {
                dataByPhi[phi] = data.filter(item => item['Phi [deg]'] === phi);
            });
        
            const [station, rotated_fields] = createStationArrayWithRotatedFields(tileArrangement, tile_array, dataByPhi[phi_angle]);
            const theta = dataByPhi[phi_angle].map(item => item['Theta [deg]']).filter((item, index, self) => self.indexOf(item) === index);
            const phi = dataByPhi[phi_angle].map(item => item['Phi [deg]']).filter((item, index, self) => self.indexOf(item) === index);
        
            const AF = computeAF(theta, phi, station);
            const applied_field = applyAFOnField(dataByPhi[phi_angle], AF);
        
            // Filtrar os valores de Theta entre -90 e 90 graus
            const filtered_applied_field = applied_field.filter(item => item['Theta [deg]'] >= -90 && item['Theta [deg]'] <= 90);
        
            const x_values = filtered_applied_field.map(item => item['Theta [deg]']);
            const y_values = filtered_applied_field.map(item => db(item['rETotal [V]']));
        
            const trace = {
                x: x_values,
                y: y_values,
                mode: 'lines',
                name: stationName
            };
        
            const layout = {
                title: `Campo Elétrico Total para Phi = ${phi_angle}° (Freq: ${selectedFrequency})`,
                xaxis: { title: 'Theta (deg)' },
                yaxis: { title: 'rETotal (dBV)' },
                font: {
                    family: "Courier New, monospace",
                    size: 12,
                    color: '#f8f8f2'
                },
                plot_bgcolor: '#282a36',
                paper_bgcolor: '#282a36',
                xaxis: { gridcolor: '#44475a' },
                yaxis: { gridcolor: '#44475a' }
            };
        
            Plotly.newPlot('interactive-plot', [trace], layout);
        }
    </script>
</body>
</html>
